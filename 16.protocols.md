Protocols are a mechanism to achieve polymorphism in Elixir when you want behavior to vary depending on the data type. 

    defprotocol Utility do
      @spec type(t) :: String.t()
      def type(value)
    end

    # dispatching on a protocol is available to any data type that has implemented 
    # the protocol and a protocol can be implemented by anyone, at any time
    defimpl Utility, for: BitString do
      def type(_value), do: "string"
    end

    defimpl Utility, for: Integer do
      def type(_value), do: "integer"
    end

    IO.puts(Utility.type("foo")) # "string"
    IO.puts(Utility.type(123)) # "integer"

Another example:

    defprotocol Size do
      @doc "Calculates the size (and not the length!) of a data structure"
      def size(data)
    end

    defimpl Size, for: BitString do
      def size(string), do: byte_size(string)
    end

    defimpl Size, for: Map do
      def size(map), do: map_size(map)
    end

    defimpl Size, for: Tuple do
      def size(tuple), do: tuple_size(tuple)
    end

    IO.puts(Size.size("foo")) # 3
    IO.puts(Size.size({:ok, "hello"})) # 2
    IO.puts(Size.size(%{label: "some label"})) # 1
    # Size.size([1, 2, 3])  #** (Protocol.UndefinedError) protocol Size not implemented for [1, 2, 3]
    
It’s possible to implement protocols for all Elixir data types:

* Atom
* BitString
* Float
* Function
* Integer
* List
* Map
* PID
* Port
* Reference
* Tuple

# Protocols and structs
The power of Elixir’s extensibility comes when protocols and structs are used together.
MapSet is a struct

    set = %MapSet{} = MapSet.new
    Size.size(set) # ** (Protocol.UndefinedError) protocol Size not implemented for #MapSet<[]> of type MapSet (a struct)

Instead of sharing protocol implementation with maps, structs require their own protocol implementation.

    defimpl Size, for: MapSet do
      def size(set), do: MapSet.size(set)
    end

    IO.puts(Size.size(set)) # 0

you could come up with your own semantics for the size of your struct.

    defmodule User do
      defstruct [:name, :age]
    end

    defimpl Size, for: User do
      def size(_user), do: 2
    end
