Elixir has three error mechanisms: errors, throws, and exits

# Errors
Errors (or exceptions) are used when exceptional things happen in the code

    iex> :foo + 1
    ** (ArithmeticError) bad argument in arithmetic expression
        :erlang.+(:foo, 1)
        
A runtime error can be raised

    iex> raise "oops"
    ** (RuntimeError) oops
    
    # passing the error name and a list of keyword arguments:
    iex> raise ArgumentError, message: "invalid argument foo"
    ** (ArgumentError) invalid argument foo
    
define your own errors by creating a module and using the defexception construct inside it

    iex> defmodule MyError do
    iex>   defexception message: "default message"
    iex> end
    iex> raise MyError
    ** (MyError) default message
    iex> raise MyError, message: "custom message"
    ** (MyError) custom message

Errors can be rescued using the try/rescue construct

    iex> try do
    ...>   raise "oops"
    ...> rescue
    ...>   e in RuntimeError -> e
    ...> end
    %RuntimeError{message: "oops"}
rescues the runtime error and returns the error itself

In practice, however, Elixir developers rarely use the try/rescue construct. 
Elixir instead provides a File.read/1 function which returns a tuple containing information about whether the file was opened successfully:

    # There is no try/rescue here
    iex> File.read("hello")
    {:error, :enoent}
    iex> File.write("hello", "world")
    :ok
    iex> File.read("hello")
    {:ok, "world"}

In case you want to handle multiple outcomes of opening a file, you can use pattern matching within the case construct:

    iex> case File.read("hello") do
    ...>   {:ok, body} -> IO.puts("Success: #{body}")
    ...>   {:error, reason} -> IO.puts("Error: #{reason}")
    ...> end

Use !, raises an exception if thereâ€™s an error. 

    iex> File.read!("unknown")
    ** (File.Error) could not read file unknown: no such file or directory
        (elixir) lib/file.ex:272: File.read!/1
