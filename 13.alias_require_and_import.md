# Alias

    defmodule Stats do
      alias Math.List, as: List
      
      # Aliases are frequently used to define shortcuts. calling alias without an :as option
      # alias Math.List
      
      # In the remaining module definition List expands to Math.List.
    end
    
alias is lexically scoped, which allows you to set aliases inside specific functions

    defmodule Math do
      # the alias will be valid only inside the function plus/2. minus/2 wonâ€™t be affected at all
      def plus(a, b) do
        alias Math.List
        # ...
      end

      def minus(a, b) do
        # ...
      end
    end

# require
Elixir provides macros as a mechanism for meta-programming (writing code that generates code). Macros are expanded at compile time.

Public functions in modules are globally available, but in order to use macros, you need to opt-in by requiring the module they are defined in.

    iex> Integer.is_odd(3)
    ** (CompileError) iex:1: you must require Integer before invoking the macro Integer.is_odd/1
        (elixir) src/elixir_dispatch.erl:97: :elixir_dispatch.dispatch_require/6
    iex> require Integer
    Integer
    iex> Integer.is_odd(3)
    true
In Elixir, Integer.is_odd/1 is defined as a macro so that it can be used as a guard. 

# import
We use import whenever we want to access functions or macros from other modules without using the fully-qualified name. 

    # We imported only the function duplicate (with arity 2) from List. :except could also be given as an option
    iex> import List, only: [duplicate: 2]
    List
    iex> duplicate(:ok, 3)
    [:ok, :ok, :ok]

import is lexically scoped too. 

    defmodule Math do
        # the imported List.duplicate/2 is only visible within that specific function.
        def some_function do
            import List, only: [duplicate: 2]
            duplicate(:ok, 10)
        end
    end
Note that imports are generally discouraged in the language. When working on your own code, prefer alias to import.

# use
The use macro is frequently used as an extension point. 
This means that, when you use a module FooBar, you allow that module to inject any code in the current module, such as importing itself or other modules, defining new functions, setting a module state, etc.
