# Binaries, strings, and charlists
In Elixir you can use a ? in front of a character literal to reveal its code point:

    iex> ?a
    97
    iex> ?ł
    322
    
we can represent any Unicode character in an Elixir string by using the \u notation and the hex representation of its code point number:

    iex> "\u0061" === "a"
    true
    iex> 0x0061 = 97 = ?a
    97
    
Elixir uses UTF-8 to encode its strings, which means that code points are encoded as a series of 8-bit bytes. 
UTF-8 is a variable width character encoding that uses one to four bytes to store each code point; 
it is capable of encoding all valid Unicode code points.

    iex> string = "hełło"
    "hełło"
    iex> String.length(string)
    5
    iex> byte_size(string)
    7
String.length/1 counts graphemes, but byte_size/1 reveals the number of underlying raw bytes needed to store the string when using UTF-8 encoding. 
UTF-8 requires one byte to represent the characters h, e, and o, but two bytes to represent ł.

A common trick in Elixir when you want to see the inner binary representation of a string is to concatenate the null byte <<0>> to it:

    iex> "hełło" <> <<0>>
    <<104, 101, 197, 130, 197, 130, 111, 0>>
Alternatively, you can view a string’s binary representation by using IO.inspect/2:

    iex> IO.inspect("hełło", binaries: :as_binaries)

## Bitstrings
we still need to go a bit deeper into how exactly we store the encoded bytes, and this is where we introduce the bitstring. 
A bitstring is a fundamental data type in Elixir, denoted with the <<>> syntax. A bitstring is a contiguous sequence of bits in memory.

By default, 8 bits (i.e. 1 byte) is used to store each number in a bitstring, but you can manually specify the number of bits via a ::n modifier to denote the size in n bits, or you can use the more verbose declaration ::size(n):

    iex> <<42>> === <<42::8>>
    true
    iex> <<3::4>>
    <<3::size(4)>>
For example, the decimal number 3 when represented with 4 bits in base 2 would be 0011, which is equivalent to the values 0, 0, 1, 1, each stored using 1 bit:

    iex> <<0::1, 0::1, 1::1, 1::1>> == <<3::4>>
    true
Any value that exceeds what can be stored by the number of bits provisioned is truncated:

    # 257 in base 2 would be represented as 100000001, but since we have reserved only 8 bits for its representation (by default), 
    # the left-most bit is ignored and the value becomes truncated to 00000001, or simply 1 in decimal
    iex> <<1>> === <<257>>
    true
    <<104, 101, 197, 130, 197, 130, 111>>
